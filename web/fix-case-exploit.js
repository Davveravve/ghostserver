const fs = require('fs');

// 1. Update API to select winner server-side
const apiContent = `import { NextRequest, NextResponse } from 'next/server'
import { jwtVerify } from 'jose'
import { prisma } from '@/lib/prisma'
import { getCaseById, getCaseItems } from '@/lib/items-data'

export async function POST(request: NextRequest) {
  const token = request.cookies.get('ghost-session')?.value

  if (!token) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  try {
    const secret = new TextEncoder().encode(
      process.env.NEXTAUTH_SECRET || 'your-secret-key'
    )
    const { payload } = await jwtVerify(token, secret)
    const steamId = payload.steamId as string

    const { caseId } = await request.json()

    // Hämta case data
    const caseData = getCaseById(caseId)
    if (!caseData) {
      return NextResponse.json({ error: 'Case not found' }, { status: 404 })
    }

    // Hämta spelaren
    const player = await prisma.player.findUnique({
      where: { steamId },
    })

    if (!player) {
      return NextResponse.json({ error: 'Player not found' }, { status: 404 })
    }

    // Kolla om spelaren har råd
    if (player.souls < caseData.cost) {
      return NextResponse.json({ error: 'Not enough souls' }, { status: 400 })
    }

    // Välj vinnare SERVER-SIDE (säkert, kan inte fuskas)
    const items = getCaseItems(caseId)
    const winnerIndex = Math.floor(Math.random() * items.length)
    const wonItem = items[winnerIndex]

    // Generera float value server-side
    const floatValue = wonItem.min_float + Math.random() * (wonItem.max_float - wonItem.min_float)

    // Kör allt i en transaktion - dra souls och spara item DIREKT
    const result = await prisma.$transaction(async (tx) => {
      const updatedPlayer = await tx.player.update({
        where: { id: player.id },
        data: {
          souls: { decrement: caseData.cost },
          casesOpened: { increment: 1 },
        },
      })

      const inventoryItem = await tx.inventoryItem.create({
        data: {
          playerId: player.id,
          itemId: wonItem.id,
          name: wonItem.name,
          weapon: wonItem.weapon,
          skinName: wonItem.name,
          wear: wonItem.wear,
          floatValue,
          imageUrl: wonItem.image_url,
          dopplerPhase: wonItem.doppler_phase,
          itemType: wonItem.type,
          obtainedFrom: caseData.name,
        },
      })

      await tx.caseOpen.create({
        data: {
          playerId: player.id,
          caseName: caseData.name,
          caseId,
          itemId: wonItem.id,
          itemName: wonItem.name,
          itemWeapon: wonItem.weapon,
          itemWear: wonItem.wear,
          floatValue,
          soulsCost: caseData.cost,
        },
      })

      await tx.soulTransaction.create({
        data: {
          playerId: player.id,
          amount: -caseData.cost,
          type: 'case_open',
          description: \`Opened \${caseData.name}\`,
          balanceAfter: updatedPlayer.souls,
        },
      })

      return { updatedPlayer, inventoryItem }
    })

    // Returnera vinnaren så frontend kan visa animationen
    return NextResponse.json({
      success: true,
      newBalance: result.updatedPlayer.souls,
      wonItem: {
        ...wonItem,
        floatValue,
      },
    })
  } catch (error) {
    console.error('Failed to open case:', error)
    return NextResponse.json(
      { error: 'Failed to open case' },
      { status: 500 }
    )
  }
}
`;

fs.writeFileSync('app/api/cases/open/route.ts', apiContent);
console.log('1. Updated API - winner selected server-side');

// 2. Update CaseOpening component
const caseOpeningContent = \`'use client'

import { useState, useRef, useCallback } from 'react'
import { motion, useAnimation, AnimatePresence } from 'framer-motion'
import { cn } from '@/lib/utils'
import type { Item } from '@/types'

interface WonItem extends Item {
  floatValue: number
}

interface CaseOpeningProps {
  items: Item[]
  caseCost: number
  onOpenCase: () => Promise<{ wonItem: WonItem; newBalance: number } | null>
}

function generateRouletteItems(items: Item[], count: number = 50): Item[] {
  const result: Item[] = []
  for (let i = 0; i < count; i++) {
    const randomIndex = Math.floor(Math.random() * items.length)
    result.push(items[randomIndex])
  }
  return result
}

export function CaseOpening({ items, caseCost, onOpenCase }: CaseOpeningProps) {
  const [isSpinning, setIsSpinning] = useState(false)
  const [hasResult, setHasResult] = useState(false)
  const [wonItem, setWonItem] = useState<WonItem | null>(null)
  const [rouletteItems, setRouletteItems] = useState<Item[]>([])
  const [error, setError] = useState<string | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const controls = useAnimation()

  const ITEM_WIDTH = 168
  const VISIBLE_ITEMS = 7
  const WINNING_INDEX = 40

  const startSpin = useCallback(async () => {
    if (isSpinning || items.length === 0) return

    setIsSpinning(true)
    setHasResult(false)
    setWonItem(null)
    setError(null)

    // FÖRST: Anropa API och få vinnaren INNAN animationen
    const result = await onOpenCase()

    if (!result) {
      setIsSpinning(false)
      setError('Failed to open case. Check your balance.')
      return
    }

    const winner = result.wonItem

    // Generera roulette items och placera vinnaren
    const generated = generateRouletteItems(items, 50)
    generated[WINNING_INDEX] = winner
    setRouletteItems(generated)

    // Reset position
    await controls.set({ x: 0 })

    const randomOffset = (Math.random() - 0.5) * (ITEM_WIDTH * 0.4)
    const containerWidth = containerRef.current?.offsetWidth || ITEM_WIDTH * VISIBLE_ITEMS
    const centerOffset = containerWidth / 2 - ITEM_WIDTH / 2
    const targetX = -(WINNING_INDEX * ITEM_WIDTH) + centerOffset + randomOffset

    // Kör animationen
    await controls.start({
      x: targetX,
      transition: {
        duration: 6,
        ease: [0.15, 0.85, 0.35, 1],
      },
    })

    setIsSpinning(false)
    setHasResult(true)
    setWonItem(winner)
  }, [items, isSpinning, controls, onOpenCase])

  const reset = () => {
    setHasResult(false)
    setWonItem(null)
    setError(null)
    controls.set({ x: 0 })
  }

  return (
    <div className="w-full">
      <div
        ref={containerRef}
        className="relative overflow-hidden bg-ghost-card rounded-lg border border-white/10"
      >
        <div className="absolute top-0 bottom-0 left-1/2 w-0.5 bg-accent-primary z-10 -translate-x-1/2" />
        <div className="absolute top-0 left-1/2 -translate-x-1/2 z-10">
          <div className="w-0 h-0 border-l-[8px] border-r-[8px] border-t-[12px] border-l-transparent border-r-transparent border-t-accent-primary" />
        </div>

        <div className="absolute inset-y-0 left-0 w-24 bg-gradient-to-r from-ghost-card to-transparent z-10 pointer-events-none" />
        <div className="absolute inset-y-0 right-0 w-24 bg-gradient-to-l from-ghost-card to-transparent z-10 pointer-events-none" />

        <motion.div
          animate={controls}
          className="flex py-4"
          style={{ width: 'fit-content' }}
        >
          {rouletteItems.length > 0 ? (
            rouletteItems.map((item, index) => (
              <RouletteItem
                key={\`\${item.id}-\${index}\`}
                item={item}
                isWinner={hasResult && index === WINNING_INDEX}
              />
            ))
          ) : (
            Array.from({ length: VISIBLE_ITEMS + 2 }).map((_, i) => (
              <div
                key={i}
                className="flex-shrink-0 w-[160px] h-[160px] mx-1 rounded-lg bg-ghost-elevated border border-white/5"
              />
            ))
          )}
        </motion.div>
      </div>

      {error && (
        <div className="mt-4 p-3 bg-red-500/10 border border-red-500/30 rounded-lg text-red-400 text-center">
          {error}
        </div>
      )}

      <AnimatePresence>
        {hasResult && wonItem && (
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            className="mt-8"
          >
            <ItemReveal item={wonItem} floatValue={wonItem.floatValue} />
          </motion.div>
        )}
      </AnimatePresence>

      <div className="mt-6 flex justify-center gap-4">
        {!hasResult ? (
          <button
            onClick={startSpin}
            disabled={isSpinning || items.length === 0}
            className={cn(
              'px-8 py-4 rounded-lg font-heading font-bold text-xl transition-all',
              isSpinning
                ? 'bg-gray-700 cursor-not-allowed'
                : 'bg-gradient-to-r from-accent-primary to-accent-secondary hover:shadow-glow hover:scale-105'
            )}
          >
            {isSpinning ? 'Opening...' : \`OPEN CASE (\${caseCost} souls)\`}
          </button>
        ) : (
          <div className="flex gap-4">
            <button
              onClick={startSpin}
              className="px-8 py-4 rounded-lg font-heading font-bold text-xl bg-gradient-to-r from-accent-primary to-accent-secondary hover:shadow-glow hover:scale-105 transition-all"
            >
              OPEN AGAIN
            </button>
            <button
              onClick={reset}
              className="px-8 py-4 rounded-lg font-heading font-bold text-xl bg-ghost-card border border-white/10 hover:border-white/30 transition-all"
            >
              CLOSE
            </button>
          </div>
        )}
      </div>
    </div>
  )
}

const wearColors: Record<string, string> = {
  FN: 'text-green-400',
  MW: 'text-lime-400',
  FT: 'text-yellow-400',
  WW: 'text-orange-400',
  BS: 'text-red-400',
}

const wearBorderColors: Record<string, string> = {
  FN: 'border-green-400',
  MW: 'border-lime-400',
  FT: 'border-yellow-400',
  WW: 'border-orange-400',
  BS: 'border-red-400',
}

const wearBgColors: Record<string, string> = {
  FN: 'bg-green-400/20',
  MW: 'bg-lime-400/20',
  FT: 'bg-yellow-400/20',
  WW: 'bg-orange-400/20',
  BS: 'bg-red-400/20',
}

const wearNames: Record<string, string> = {
  FN: 'Factory New',
  MW: 'Minimal Wear',
  FT: 'Field-Tested',
  WW: 'Well-Worn',
  BS: 'Battle-Scarred',
}

function RouletteItem({ item, isWinner }: { item: Item; isWinner: boolean }) {
  return (
    <div
      className={cn(
        'flex-shrink-0 w-[160px] h-[160px] mx-1 rounded-lg border transition-all duration-300',
        'bg-ghost-elevated flex flex-col items-center justify-center p-2',
        isWinner ? 'border-accent-primary' : 'border-white/10'
      )}
    >
      <div className="w-24 h-24 rounded-lg mb-2 flex items-center justify-center overflow-hidden bg-white/5">
        {item.image_url ? (
          <img
            src={item.image_url}
            alt={item.name}
            className="w-full h-full object-contain"
          />
        ) : (
          <span className="text-3xl text-gray-500">?</span>
        )}
      </div>
      <span className="text-[10px] text-gray-400 truncate w-full text-center">
        {item.weapon}
      </span>
      <span className="text-xs font-semibold truncate w-full text-center text-white">
        {item.name}
      </span>
    </div>
  )
}

function ItemReveal({ item, floatValue }: { item: Item; floatValue: number }) {
  const isKnifeOrGloves = item.type === 'knife' || item.type === 'gloves'

  return (
    <motion.div
      initial={{ scale: 0.8, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      transition={{ type: 'spring', duration: 0.5 }}
      className="text-center"
    >
      <motion.h2
        initial={{ y: -20 }}
        animate={{ y: 0 }}
        className={cn(
          'font-heading text-3xl font-bold mb-4',
          isKnifeOrGloves ? 'text-yellow-400' : 'text-white'
        )}
      >
        {isKnifeOrGloves ? 'INCREDIBLE!' : 'You won!'}
      </motion.h2>

      <motion.div
        initial={{ rotateY: 90 }}
        animate={{ rotateY: 0 }}
        transition={{ duration: 0.6, ease: 'easeOut' }}
        className={cn(
          'inline-block p-6 rounded-xl border-2',
          wearBorderColors[item.wear],
          'bg-ghost-card'
        )}
      >
        <div className="w-40 h-40 mx-auto rounded-lg mb-4 flex items-center justify-center overflow-hidden bg-white/10">
          {item.image_url ? (
            <img
              src={item.image_url}
              alt={item.name}
              className="w-full h-full object-contain"
            />
          ) : (
            <span className="text-5xl text-gray-500">?</span>
          )}
        </div>
        <div className="text-gray-400 text-sm mb-1">{item.weapon}</div>
        <div className="text-xl font-bold text-white">{item.name}</div>
        <div className="mt-3 flex items-center justify-center gap-3">
          <div className={cn(
            'px-3 py-1 rounded-full text-sm font-medium',
            wearBgColors[item.wear],
            wearColors[item.wear]
          )}>
            {wearNames[item.wear]}
          </div>
          <div className="px-3 py-1 rounded-full bg-white/10 text-white text-sm font-mono">
            {floatValue.toFixed(8)}
          </div>
        </div>
      </motion.div>

      <div className="mt-6 flex justify-center gap-4">
        <a
          href="/inventory"
          className="px-4 py-2 rounded-md bg-ghost-card border border-white/10 hover:border-white/30 text-sm transition-all"
        >
          View in Inventory
        </a>
      </div>
    </motion.div>
  )
}
\`;

fs.writeFileSync('components/cases/CaseOpening.tsx', caseOpeningContent);
console.log('2. Updated CaseOpening - API called before animation');

// 3. Update the page
const pageContent = \`'use client'

import { useState, useEffect, useCallback } from 'react'
import Link from 'next/link'
import { CaseOpening } from '@/components/cases/CaseOpening'
import { cases, getCaseById, getCaseItems } from '@/lib/items-data'

export default function CaseOpenPage({ params }: { params: { caseId: string } }) {
  const [userSouls, setUserSouls] = useState<number | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  const currentCase = getCaseById(parseInt(params.caseId)) || cases[0]
  const caseItems = getCaseItems(currentCase.id)

  useEffect(() => {
    async function fetchSouls() {
      try {
        const res = await fetch('/api/inventory')
        if (res.ok) {
          const data = await res.json()
          setUserSouls(data.stats.souls)
        }
      } catch (error) {
        console.error('Failed to fetch souls:', error)
      } finally {
        setIsLoading(false)
      }
    }
    fetchSouls()
  }, [])

  const handleOpenCase = useCallback(async () => {
    try {
      const res = await fetch('/api/cases/open', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ caseId: currentCase.id }),
      })

      if (!res.ok) {
        return null
      }

      const data = await res.json()
      // Uppdatera souls DIREKT när API:n svarar
      setUserSouls(data.newBalance)
      return {
        wonItem: data.wonItem,
        newBalance: data.newBalance,
      }
    } catch (error) {
      console.error('Failed to open case:', error)
      return null
    }
  }, [currentCase.id])

  const canAfford = userSouls !== null && userSouls >= currentCase.cost

  return (
    <div className="min-h-[calc(100vh-140px)] bg-gradient-to-b from-ghost-bg via-ghost-bg to-accent-primary/5">
      <div className="max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="flex items-center justify-between mb-8">
          <div>
            <Link
              href="/cases"
              className="text-gray-400 hover:text-white text-sm mb-2 inline-flex items-center gap-1"
            >
              <svg className="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M19 12H5M12 19l-7-7 7-7" />
              </svg>
              Back to Cases
            </Link>
            <h1 className="font-heading text-3xl font-bold">{currentCase.name}</h1>
            <p className="text-gray-400">{currentCase.description}</p>
          </div>
          <div className="text-right">
            <div className="text-sm text-gray-400">Your Balance</div>
            <div className="flex items-center gap-2">
              <SoulIcon className="w-6 h-6 text-accent-primary" />
              <span className="font-heading text-2xl font-bold">
                {isLoading ? '...' : userSouls !== null ? userSouls.toLocaleString() : '0'}
              </span>
            </div>
          </div>
        </div>

        <div className="mb-8">
          <CaseOpening
            items={caseItems}
            caseCost={currentCase.cost}
            onOpenCase={handleOpenCase}
          />
        </div>

        {!isLoading && !canAfford && (
          <div className="mb-8 p-4 bg-red-500/10 border border-red-500/30 rounded-lg text-center">
            <p className="text-red-400">
              You need <span className="font-bold">{userSouls !== null ? currentCase.cost - userSouls : currentCase.cost}</span> more souls to open this case.
            </p>
            <Link href="/" className="text-accent-primary hover:underline text-sm mt-1 inline-block">
              Earn more by getting kills on our servers
            </Link>
          </div>
        )}
      </div>
    </div>
  )
}

function SoulIcon({ className }: { className?: string }) {
  return (
    <svg className={className} viewBox="0 0 24 24" fill="currentColor">
      <circle cx="12" cy="12" r="10" fillOpacity="0.2" />
      <circle cx="12" cy="12" r="4" />
    </svg>
  )
}
\`;

fs.writeFileSync('app/open/[caseId]/page.tsx', pageContent);
console.log('3. Updated page - souls update immediately');

console.log('\\nDone! Case opening exploit fixed:');
console.log('- Winner is selected SERVER-SIDE');
console.log('- Souls are deducted BEFORE animation');
console.log('- Item is saved BEFORE animation');
console.log('- Leaving page = you already got the item');
